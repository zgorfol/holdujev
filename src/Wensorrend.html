<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wen király Ji King sorrendje — Geometriai kód</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@300;400&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0f;
  --bg2: #12121a;
  --yang: #f0e6d0;
  --yin: #2a2a3a;
  --gold: #c8a44e;
  --gold-dim: #8a7235;
  --red: #b83a3a;
  --blue: #4a7a9b;
  --text: #d0c8b8;
  --text-dim: #7a7468;
  --accent: #e8d8a8;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Cormorant Garamond', serif;
  min-height: 100vh;
  overflow-x: hidden;
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  padding: 20px;
}

h1 {
  text-align: center;
  font-size: 2rem;
  font-weight: 400;
  color: var(--accent);
  letter-spacing: 0.15em;
  margin: 20px 0 5px;
  text-transform: uppercase;
}

h1 span {
  display: block;
  font-size: 0.55em;
  color: var(--text-dim);
  letter-spacing: 0.3em;
  margin-top: 4px;
}

.main-layout {
  display: flex;
  gap: 24px;
  margin-top: 20px;
  align-items: flex-start;
}

.circle-panel {
  flex: 1;
  min-width: 0;
  position: relative;
}

.side-panel {
  width: 340px;
  flex-shrink: 0;
}

.svg-container {
  width: 100%;
  aspect-ratio: 1;
  position: relative;
}

svg {
  width: 100%;
  height: 100%;
}

.controls {
  background: var(--bg2);
  border: 1px solid #2a2a35;
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

.controls h3 {
  font-size: 0.95rem;
  color: var(--gold);
  margin-bottom: 12px;
  letter-spacing: 0.1em;
}

.btn-row {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}

.btn {
  background: transparent;
  border: 1px solid #3a3a4a;
  color: var(--text);
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-family: 'Cormorant Garamond', serif;
  font-size: 0.85rem;
  transition: all 0.3s;
}

.btn:hover { border-color: var(--gold); color: var(--gold); }
.btn.active { background: var(--gold); color: var(--bg); border-color: var(--gold); }

.slider-group {
  margin: 12px 0;
}

.slider-group label {
  display: flex;
  justify-content: space-between;
  font-size: 0.85rem;
  color: var(--text-dim);
  margin-bottom: 4px;
}

input[type="range"] {
  width: 100%;
  -webkit-appearance: none;
  height: 3px;
  background: #3a3a4a;
  border-radius: 2px;
  outline: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--gold);
  cursor: pointer;
}

.info-box {
  background: var(--bg2);
  border: 1px solid #2a2a35;
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

.info-box h3 {
  font-size: 0.95rem;
  color: var(--gold);
  margin-bottom: 8px;
  letter-spacing: 0.1em;
}

.hex-info {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.8rem;
  line-height: 1.8;
  color: var(--text-dim);
}

.hex-info .highlight {
  color: var(--accent);
}

.hex-symbol {
  font-size: 2.5rem;
  text-align: center;
  margin: 8px 0;
  color: var(--yang);
}

.legend {
  background: var(--bg2);
  border: 1px solid #2a2a35;
  border-radius: 8px;
  padding: 16px;
}

.legend h3 {
  font-size: 0.95rem;
  color: var(--gold);
  margin-bottom: 10px;
  letter-spacing: 0.1em;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 6px;
  font-size: 0.82rem;
}

.legend-swatch {
  width: 24px;
  height: 3px;
  border-radius: 2px;
  flex-shrink: 0;
}

.trigram-label {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.75rem;
}

.pair-display {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 2px;
  margin-top: 10px;
}

.pair-cell {
  aspect-ratio: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.65rem;
  font-family: 'JetBrains Mono', monospace;
  border-radius: 2px;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}

.pair-cell:hover {
  transform: scale(1.3);
  z-index: 10;
}

@media (max-width: 900px) {
  .main-layout {
    flex-direction: column;
  }
  .side-panel {
    width: 100%;
  }
}

.taijitu-note {
  text-align: center;
  font-style: italic;
  color: var(--text-dim);
  font-size: 0.85rem;
  margin: 8px 0;
  line-height: 1.5;
}
</style>
</head>
<body>

<div class="container">
  <h1>文王序卦 <span>Wen király Ji King sorrendje — A geometriai kód</span></h1>

  <div class="main-layout">
    <div class="circle-panel">
      <div class="svg-container">
        <svg id="mainSvg" viewBox="-320 -320 640 640"></svg>
      </div>
      <p class="taijitu-note" id="spiralNote">
        A spirál a leghosszabb húrtól (Qian↔Kun átmérő) halad a legrövidebb felé (Kan↔Li szomszédság = Ji Ji/Wei Ji)
      </p>
    </div>

    <div class="side-panel">
      <div class="controls">
        <h3>⚙ Megjelenítés</h3>
        <div class="btn-row">
          <button class="btn active" onclick="setView('spiral')" id="btnSpiral">Spirál</button>
          <button class="btn" onclick="setView('chords')" id="btnChords">Húrok</button>
          <button class="btn" onclick="setView('matrix')" id="btnMatrix">Mátrix</button>
          <button class="btn" onclick="setView('animate')" id="btnAnimate">Animáció</button>
        </div>
        <div class="slider-group">
          <label><span>Megmutatott párok</span><span id="pairCount">32 / 32</span></label>
          <input type="range" id="pairSlider" min="0" max="32" value="32" oninput="updatePairCount()">
        </div>
        <div class="btn-row">
          <button class="btn" onclick="toggleLayer('canon1')" id="btnCanon1">I. Kánon</button>
          <button class="btn" onclick="toggleLayer('canon2')" id="btnCanon2">II. Kánon</button>
          <button class="btn" onclick="toggleLayer('central')" id="btnCentral">Centrálok</button>
        </div>
      </div>

      <div class="info-box" id="hexInfo">
        <h3>☰ Hexagram információ</h3>
        <div class="hex-symbol" id="hexSymbol">☰☰</div>
        <div class="hex-info" id="hexDetails">
          <div><span class="highlight">Wen #1</span> — Qian (乾) — Az Alkotó</div>
          <div>Felső: ☰ Qian (111) | Alsó: ☰ Qian (111)</div>
          <div>Jang-súly: 6 | Szimmetria: 3 | Alternálás: 0</div>
          <div>Húrhossz: 0 (azonos trigramok)</div>
          <div class="highlight" style="margin-top:6px">→ Centrálhexagram (tiszta jang)</div>
        </div>
      </div>

      <div class="legend">
        <h3>Jelmagyarázat</h3>
        <div class="legend-item">
          <div class="legend-swatch" style="background: var(--gold)"></div>
          <span>I. Kánon (1–30)</span>
        </div>
        <div class="legend-item">
          <div class="legend-swatch" style="background: var(--blue)"></div>
          <span>II. Kánon (31–64)</span>
        </div>
        <div class="legend-item">
          <div class="legend-swatch" style="background: var(--red); height:5px"></div>
          <span>Centrálhexagramok (1,2,63,64)</span>
        </div>
        <div class="legend-item">
          <div class="legend-swatch" style="background: #7a9a6a; height:4px"></div>
          <span>Jin-Jang „pötty" (3,4)</span>
        </div>
        <div class="legend-item">
          <div class="legend-swatch" style="background: var(--yang); height:1px; border: 1px dashed var(--text-dim)"></div>
          <span>Szimmetrikus párok (komplementer)</span>
        </div>

        <h3 style="margin-top: 14px;">8×8 Trigram-mátrix</h3>
        <div class="pair-display" id="matrixGrid"></div>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================================
// DATA: King Wen sequence with full hexagram data
// ============================================================

const trigramNames = ['Kun ☷','Gen ☶','Kan ☵','Xun ☴','Zhen ☳','Li ☲','Dui ☱','Qian ☰'];
const trigramBin = ['000','001','010','011','100','101','110','111'];
const trigramSymbols = ['☷','☶','☵','☴','☳','☲','☱','☰'];

// Fu Xi circle order (traditional): Qian(7), Dui(6), Li(5), Zhen(4), Xun(3), Kan(2), Gen(1), Kun(0)
// Positions on circle (0=top, clockwise)
const fuxiOrder = [7, 6, 5, 4, 0, 1, 2, 3]; // S, SE, E, NE, N, NW, W, SW
const fuxiAngle = {}; // trigram index -> angle in radians
fuxiOrder.forEach((t, i) => {
  fuxiAngle[t] = (i / 8) * Math.PI * 2 - Math.PI / 2;
});

// King Wen sequence: [wenNumber, upperTrigram, lowerTrigram, name, chinese]
const wenSequence = [
  [1,7,7,"Qian","乾"],[2,0,0,"Kun","坤"],
  [3,2,4,"Zhun","屯"],[4,1,2,"Meng","蒙"],
  [5,2,7,"Xu","需"],[6,7,2,"Song","訟"],
  [7,0,2,"Shi","師"],[8,2,0,"Bi","比"],
  [9,3,7,"Xiao Xu","小畜"],[10,7,6,"Lü","履"],
  [11,0,7,"Tai","泰"],[12,7,0,"Pi","否"],
  [13,7,5,"Tong Ren","同人"],[14,5,7,"Da You","大有"],
  [15,0,1,"Qian","謙"],[16,4,0,"Yu","豫"],
  [17,6,4,"Sui","隨"],[18,1,3,"Gu","蠱"],
  [19,0,6,"Lin","臨"],[20,3,0,"Guan","觀"],
  [21,5,4,"Shi He","噬嗑"],[22,1,5,"Bi","賁"],
  [23,1,0,"Bo","剝"],[24,0,4,"Fu","復"],
  [25,7,4,"Wu Wang","無妄"],[26,1,7,"Da Xu","大畜"],
  [27,1,4,"Yi","頤"],[28,6,3,"Da Guo","大過"],
  [29,2,2,"Kan","坎"],[30,5,5,"Li","離"],
  [31,6,1,"Xian","咸"],[32,4,3,"Heng","恆"],
  [33,7,1,"Dun","遯"],[34,4,7,"Da Zhuang","大壯"],
  [35,5,0,"Jin","晉"],[36,0,5,"Ming Yi","明夷"],
  [37,3,5,"Jia Ren","家人"],[38,5,6,"Kui","睽"],
  [39,2,1,"Jian","蹇"],[40,4,2,"Jie","解"],
  [41,1,6,"Sun","損"],[42,3,4,"Yi","益"],
  [43,6,7,"Guai","夬"],[44,7,3,"Gou","姤"],
  [45,6,0,"Cui","萃"],[46,0,3,"Sheng","升"],
  [47,6,2,"Kun","困"],[48,2,3,"Jing","井"],
  [49,6,5,"Ge","革"],[50,5,3,"Ding","鼎"],
  [51,4,4,"Zhen","震"],[52,1,1,"Gen","艮"],
  [53,3,1,"Jian","漸"],[54,4,6,"Gui Mei","歸妹"],
  [55,4,5,"Feng","豐"],[56,5,1,"Lü","旅"],
  [57,3,3,"Xun","巽"],[58,6,6,"Dui","兌"],
  [59,3,2,"Huan","渙"],[60,2,6,"Jie","節"],
  [61,3,6,"Zhong Fu","中孚"],[62,4,1,"Xiao Guo","小過"],
  [63,2,5,"Ji Ji","既濟"],[64,5,2,"Wei Ji","未濟"]
];

// Build pairs
const pairs = [];
for (let i = 0; i < 64; i += 2) {
  pairs.push({
    index: i / 2,
    a: wenSequence[i],
    b: wenSequence[i + 1],
    canon: i < 30 ? 1 : 2
  });
}

// ============================================================
// SVG RENDERING
// ============================================================

const svg = document.getElementById('mainSvg');
const R = 250; // main circle radius
const TR = 30; // trigram label radius offset
let currentView = 'spiral';
let visiblePairs = 32;
let layers = { canon1: true, canon2: true, central: true };
let animationTimer = null;

function createSvgEl(tag, attrs) {
  const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
  for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
  return el;
}

function getTrigramPos(trigramIdx, radius = R) {
  const a = fuxiAngle[trigramIdx];
  return { x: Math.cos(a) * radius, y: Math.sin(a) * radius };
}

function drawTrigramSymbol(x, y, trigramIdx) {
  const g = createSvgEl('g', { transform: `translate(${x},${y})` });
  const bits = trigramBin[trigramIdx];
  for (let row = 0; row < 3; row++) {
    const ry = (row - 1) * 7;
    if (bits[row] === '1') {
      // yang line
      const line = createSvgEl('rect', {
        x: -10, y: ry - 2, width: 20, height: 4, rx: 1,
        fill: '#f0e6d0', opacity: 0.9
      });
      g.appendChild(line);
    } else {
      // yin line (broken)
      const l1 = createSvgEl('rect', { x: -10, y: ry - 2, width: 8, height: 4, rx: 1, fill: '#f0e6d0', opacity: 0.7 });
      const l2 = createSvgEl('rect', { x: 2, y: ry - 2, width: 8, height: 4, rx: 1, fill: '#f0e6d0', opacity: 0.7 });
      g.appendChild(l1);
      g.appendChild(l2);
    }
  }
  return g;
}

function chordLength(t1, t2) {
  if (t1 === t2) return 0;
  const p1 = getTrigramPos(t1);
  const p2 = getTrigramPos(t2);
  return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
}

function hexBinary(upper, lower) {
  return trigramBin[upper] + trigramBin[lower];
}

function yangWeight(upper, lower) {
  return hexBinary(upper, lower).split('').filter(b => b === '1').length;
}

function symmetryIndex(upper, lower) {
  const b = hexBinary(upper, lower);
  let s = 0;
  if (b[0] === b[5]) s++;
  if (b[1] === b[4]) s++;
  if (b[2] === b[3]) s++;
  return s;
}

function alternationIndex(upper, lower) {
  const b = hexBinary(upper, lower);
  let a = 0;
  for (let i = 0; i < 5; i++) {
    if (b[i] !== b[i + 1]) a++;
  }
  return a;
}

function render() {
  svg.innerHTML = '';
  
  // Background radial gradient
  const defs = createSvgEl('defs', {});
  const grad = createSvgEl('radialGradient', { id: 'bgGrad', cx: '50%', cy: '50%', r: '50%' });
  grad.appendChild(createSvgEl('stop', { offset: '0%', 'stop-color': '#1a1a2a', 'stop-opacity': '0.3' }));
  grad.appendChild(createSvgEl('stop', { offset: '100%', 'stop-color': '#0a0a0f', 'stop-opacity': '0' }));
  defs.appendChild(grad);
  
  // Glow filter
  const glow = createSvgEl('filter', { id: 'glow' });
  glow.appendChild(createSvgEl('feGaussianBlur', { stdDeviation: '3', result: 'blur' }));
  const merge = createSvgEl('feMerge', {});
  merge.appendChild(createSvgEl('feMergeNode', { in: 'blur' }));
  merge.appendChild(createSvgEl('feMergeNode', { in: 'SourceGraphic' }));
  glow.appendChild(merge);
  defs.appendChild(glow);
  
  svg.appendChild(defs);

  // Background circle
  svg.appendChild(createSvgEl('circle', { cx: 0, cy: 0, r: R + 40, fill: 'url(#bgGrad)' }));

  // Main circle
  svg.appendChild(createSvgEl('circle', {
    cx: 0, cy: 0, r: R, fill: 'none',
    stroke: '#2a2a3a', 'stroke-width': 1, 'stroke-dasharray': '3,6', opacity: 0.6
  }));

  // Concentric reference circles
  [0.25, 0.5, 0.75].forEach(f => {
    svg.appendChild(createSvgEl('circle', {
      cx: 0, cy: 0, r: R * f, fill: 'none',
      stroke: '#1a1a2a', 'stroke-width': 0.5, 'stroke-dasharray': '2,8'
    }));
  });

  // Trigram positions and labels
  for (let t = 0; t < 8; t++) {
    const pos = getTrigramPos(t);
    const labelPos = getTrigramPos(t, R + 35);
    
    // Position dot
    svg.appendChild(createSvgEl('circle', {
      cx: pos.x, cy: pos.y, r: 5,
      fill: t >= 4 ? '#f0e6d0' : '#4a4a5a',
      opacity: 0.8,
      stroke: '#c8a44e', 'stroke-width': 0.5
    }));

    // Trigram symbol
    svg.appendChild(drawTrigramSymbol(labelPos.x, labelPos.y, t));

    // Name
    const namePos = getTrigramPos(t, R + 58);
    const nameEl = createSvgEl('text', {
      x: namePos.x, y: namePos.y + 4,
      'text-anchor': 'middle', 'font-size': '9',
      'font-family': 'JetBrains Mono', fill: '#7a7468'
    });
    nameEl.textContent = trigramNames[t].split(' ')[0];
    svg.appendChild(nameEl);
  }

  if (currentView === 'spiral' || currentView === 'chords' || currentView === 'animate') {
    drawChords();
  } else if (currentView === 'matrix') {
    drawMatrixView();
  }
}

function drawChords() {
  const chordsGroup = createSvgEl('g', { id: 'chords' });
  
  const maxPairs = visiblePairs;
  
  for (let pi = 0; pi < maxPairs; pi++) {
    const pair = pairs[pi];
    const hex = pair.a;
    const [wn, upper, lower] = hex;
    
    if (!layers.canon1 && pair.canon === 1) continue;
    if (!layers.canon2 && pair.canon === 2) continue;

    const isCentral = [1, 2, 63, 64].includes(pair.a[0]) || [1, 2, 63, 64].includes(pair.b[0]);
    const isDot = [3, 4].includes(pair.a[0]) || [3, 4].includes(pair.b[0]);
    const isSymmetricPair = pair.a[1] === pair.a[2] || pair.b[1] === pair.b[2]; // same upper/lower = symmetric

    const p1 = getTrigramPos(pair.a[1]);
    const p2 = getTrigramPos(pair.a[2]);

    let color, width, opacity, dashArray = 'none';

    if (isCentral && layers.central) {
      color = '#b83a3a';
      width = 3;
      opacity = 0.9;
    } else if (isDot) {
      color = '#7a9a6a';
      width = 2.5;
      opacity = 0.85;
    } else if (pair.canon === 1) {
      color = '#c8a44e';
      width = 1.2;
      opacity = 0.35 + (pi / 32) * 0.3;
    } else {
      color = '#4a7a9b';
      width = 1.2;
      opacity = 0.3 + ((pi - 15) / 17) * 0.35;
    }

    // Check if same trigram (point, not chord)
    if (pair.a[1] === pair.a[2]) {
      const p = getTrigramPos(pair.a[1]);
      const dot = createSvgEl('circle', {
        cx: p.x, cy: p.y, r: isCentral ? 10 : 7,
        fill: 'none', stroke: color,
        'stroke-width': width, opacity: opacity,
        'data-pair': pi, cursor: 'pointer'
      });
      dot.addEventListener('click', () => showPairInfo(pi));
      dot.addEventListener('mouseenter', () => highlightPair(pi));
      dot.addEventListener('mouseleave', () => render());
      chordsGroup.appendChild(dot);
    } else {
      // Draw chord
      if (currentView === 'spiral') {
        // Curved chord showing spiral order
        const mid = {
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2
        };
        const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
        // Curve amount based on pair index (spiral effect)
        const curveFactor = (pi / 32) * 40 * (pi % 2 === 0 ? 1 : -1);
        const nx = -(p2.y - p1.y) / dist;
        const ny = (p2.x - p1.x) / dist;
        const cp = {
          x: mid.x + nx * curveFactor,
          y: mid.y + ny * curveFactor
        };

        const path = createSvgEl('path', {
          d: `M ${p1.x} ${p1.y} Q ${cp.x} ${cp.y} ${p2.x} ${p2.y}`,
          fill: 'none', stroke: color,
          'stroke-width': width, opacity: opacity,
          'stroke-linecap': 'round',
          'data-pair': pi, cursor: 'pointer'
        });
        if (symmetryIndex(pair.a[1], pair.a[2]) === 3) {
          path.setAttribute('stroke-dasharray', '6,4');
        }
        path.addEventListener('click', () => showPairInfo(pi));
        path.addEventListener('mouseenter', () => highlightPair(pi));
        path.addEventListener('mouseleave', () => render());
        chordsGroup.appendChild(path);
      } else {
        // Straight chord
        const line = createSvgEl('line', {
          x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
          stroke: color, 'stroke-width': width,
          opacity: opacity, 'stroke-linecap': 'round',
          'data-pair': pi, cursor: 'pointer'
        });
        if (symmetryIndex(pair.a[1], pair.a[2]) === 3) {
          line.setAttribute('stroke-dasharray', '6,4');
        }
        line.addEventListener('click', () => showPairInfo(pi));
        line.addEventListener('mouseenter', () => highlightPair(pi));
        line.addEventListener('mouseleave', () => render());
        chordsGroup.appendChild(line);
      }
    }

    // Pair number label
    if (maxPairs <= 16 || isCentral || isDot) {
      const labelPos = {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2
      };
      if (pair.a[1] === pair.a[2]) {
        labelPos.x += 15;
        labelPos.y -= 5;
      }
      const label = createSvgEl('text', {
        x: labelPos.x, y: labelPos.y + 3,
        'text-anchor': 'middle', 'font-size': '8',
        'font-family': 'JetBrains Mono', fill: color,
        opacity: Math.min(1, opacity + 0.3),
        'pointer-events': 'none'
      });
      label.textContent = `${pair.a[0]}-${pair.b[0]}`;
      chordsGroup.appendChild(label);
    }
  }

  svg.appendChild(chordsGroup);

  // Draw small taijitu at center
  drawTaijitu();
}

function drawTaijitu() {
  const g = createSvgEl('g', { opacity: '0.3' });
  const r = 20;
  
  // White half
  const white = createSvgEl('path', {
    d: `M 0 ${-r} A ${r} ${r} 0 0 1 0 ${r} A ${r/2} ${r/2} 0 0 0 0 0 A ${r/2} ${r/2} 0 0 1 0 ${-r}`,
    fill: '#f0e6d0', opacity: '0.15'
  });
  g.appendChild(white);
  
  // Black half
  const black = createSvgEl('path', {
    d: `M 0 ${r} A ${r} ${r} 0 0 1 0 ${-r} A ${r/2} ${r/2} 0 0 0 0 0 A ${r/2} ${r/2} 0 0 1 0 ${r}`,
    fill: '#2a2a3a', opacity: '0.3'
  });
  g.appendChild(black);

  // Dots
  g.appendChild(createSvgEl('circle', { cx: 0, cy: -r/2, r: 3, fill: '#2a2a3a', opacity: '0.4' }));
  g.appendChild(createSvgEl('circle', { cx: 0, cy: r/2, r: 3, fill: '#f0e6d0', opacity: '0.2' }));

  // Border
  g.appendChild(createSvgEl('circle', { cx: 0, cy: 0, r: r, fill: 'none', stroke: '#3a3a4a', 'stroke-width': 0.5 }));
  
  svg.appendChild(g);
}

function drawMatrixView() {
  // 8x8 matrix inside the circle
  const cellSize = 50;
  const offset = -cellSize * 4;
  const g = createSvgEl('g', {});

  // Draw grid
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const upper = 7 - row; // Qian at top
      const lower = 7 - col; // Qian at left
      
      // Find this hexagram in Wen sequence
      const wenEntry = wenSequence.find(h => h[1] === upper && h[2] === lower);
      const wenNum = wenEntry ? wenEntry[0] : '?';
      
      const isCentral = [1, 2, 63, 64].includes(wenNum);
      const isDot = [3, 4].includes(wenNum);
      const isCanon1 = wenNum <= 30;

      let fill = isCanon1 ? 'rgba(200,164,78,0.1)' : 'rgba(74,122,155,0.1)';
      if (isCentral) fill = 'rgba(184,58,58,0.25)';
      if (isDot) fill = 'rgba(122,154,106,0.2)';

      const x = offset + col * cellSize;
      const y = offset + row * cellSize;

      const rect = createSvgEl('rect', {
        x, y, width: cellSize - 2, height: cellSize - 2,
        fill, stroke: '#2a2a35', 'stroke-width': 0.5,
        rx: 3, cursor: 'pointer'
      });
      
      const pairIdx = pairs.findIndex(p => p.a[0] === wenNum || p.b[0] === wenNum);
      rect.addEventListener('click', () => { if (pairIdx >= 0) showPairInfo(pairIdx); });
      g.appendChild(rect);

      const text = createSvgEl('text', {
        x: x + cellSize / 2 - 1, y: y + cellSize / 2 + 4,
        'text-anchor': 'middle', 'font-size': '11',
        'font-family': 'JetBrains Mono',
        fill: isCentral ? '#b83a3a' : isDot ? '#7a9a6a' : isCanon1 ? '#c8a44e' : '#4a7a9b',
        opacity: 0.8, 'pointer-events': 'none'
      });
      text.textContent = wenNum;
      g.appendChild(text);
    }
  }

  // Row/column labels (trigrams)
  for (let i = 0; i < 8; i++) {
    const t = 7 - i;
    const rowLabel = createSvgEl('text', {
      x: offset - 14, y: offset + i * cellSize + cellSize / 2 + 3,
      'text-anchor': 'middle', 'font-size': '16',
      fill: '#7a7468', 'pointer-events': 'none'
    });
    rowLabel.textContent = trigramSymbols[t];
    g.appendChild(rowLabel);

    const colLabel = createSvgEl('text', {
      x: offset + i * cellSize + cellSize / 2 - 1, y: offset - 10,
      'text-anchor': 'middle', 'font-size': '16',
      fill: '#7a7468', 'pointer-events': 'none'
    });
    colLabel.textContent = trigramSymbols[t];
    g.appendChild(colLabel);
  }

  // Labels
  const upperLabel = createSvgEl('text', {
    x: offset - 14, y: offset - 28,
    'text-anchor': 'middle', 'font-size': '9',
    'font-family': 'JetBrains Mono', fill: '#5a5a6a'
  });
  upperLabel.textContent = 'Felső ↓';
  g.appendChild(upperLabel);

  const lowerLabel = createSvgEl('text', {
    x: offset + cellSize * 2, y: offset - 28,
    'text-anchor': 'middle', 'font-size': '9',
    'font-family': 'JetBrains Mono', fill: '#5a5a6a'
  });
  lowerLabel.textContent = 'Alsó →';
  g.appendChild(lowerLabel);

  svg.appendChild(g);
}

function highlightPair(pairIdx) {
  // Just show info without full re-render for performance
  showPairInfo(pairIdx);
}

function showPairInfo(pairIdx) {
  const pair = pairs[pairIdx];
  const a = pair.a;
  const b = pair.b;
  
  const hexUniBase = 0x4DC0;
  const symA = String.fromCodePoint(hexUniBase + a[0] - 1);
  const symB = String.fromCodePoint(hexUniBase + b[0] - 1);
  
  document.getElementById('hexSymbol').textContent = `${symA} ${symB}`;
  
  const cl = chordLength(a[1], a[2]);
  const w = yangWeight(a[1], a[2]);
  const s = symmetryIndex(a[1], a[2]);
  const alt = alternationIndex(a[1], a[2]);
  
  const isCentral = [1, 2, 63, 64].includes(a[0]);
  const isDot = [3, 4].includes(a[0]);
  
  let special = '';
  if (isCentral) special = `<div class="highlight" style="margin-top:6px; color:#b83a3a">→ Centrálhexagram</div>`;
  if (isDot) special = `<div class="highlight" style="margin-top:6px; color:#7a9a6a">→ Jin-jang „pötty" — az ellentét magjának megjelenése</div>`;
  
  const isSymPair = a[1] === a[2] || (hexBinary(a[1], a[2]) === hexBinary(a[1], a[2]).split('').reverse().join(''));
  const pairType = isSymPair ? 'Komplementer pár' : 'Megfordítás (inverz) pár';
  
  document.getElementById('hexDetails').innerHTML = `
    <div><span class="highlight">Wen #${a[0]}</span> — ${a[3]} (${a[4]}) | <span class="highlight">#${b[0]}</span> — ${b[3]} (${b[4]})</div>
    <div style="margin-top:4px">Felső: ${trigramSymbols[a[1]]} ${trigramNames[a[1]]} (${trigramBin[a[1]]}) | Alsó: ${trigramSymbols[a[2]]} ${trigramNames[a[2]]} (${trigramBin[a[2]]})</div>
    <div>Bináris: ${hexBinary(a[1], a[2])}</div>
    <div style="margin-top:4px">Jang-súly: ${w} | Szimmetria: ${s} | Alternálás: ${alt}</div>
    <div>Húrhossz: ${cl.toFixed(0)} (Fu Xi-körön)</div>
    <div style="margin-top:4px; color:#8a7235">${pairType} | ${pair.canon === 1 ? 'I.' : 'II.'} Kánon</div>
    ${special}
  `;
}

function setView(view) {
  if (animationTimer) { clearInterval(animationTimer); animationTimer = null; }
  
  currentView = view;
  document.querySelectorAll('.btn-row .btn').forEach(b => b.classList.remove('active'));
  
  if (view === 'spiral') document.getElementById('btnSpiral').classList.add('active');
  if (view === 'chords') document.getElementById('btnChords').classList.add('active');
  if (view === 'matrix') document.getElementById('btnMatrix').classList.add('active');
  if (view === 'animate') {
    document.getElementById('btnAnimate').classList.add('active');
    startAnimation();
  }
  
  const notes = {
    spiral: 'A spirál a leghosszabb húrtól (Qian↔Kun átmérő) halad a legrövidebb felé (Kan↔Li szomszédság = Ji Ji/Wei Ji)',
    chords: 'Egyenes húrok a Fu Xi-körön — minden húr egy hexagrampárt képvisel. A húrhossz a két trigram távolsága.',
    matrix: '8×8-as trigram-mátrix. A számok a Wen-féle sorszámot mutatják. Figyeld meg az I. és II. Kánon eloszlását!',
    animate: 'A Wen-féle sorrend kibontakozása — a kozmogóniai spirál időbeli megjelenítése'
  };
  document.getElementById('spiralNote').textContent = notes[view] || '';
  
  render();
}

function startAnimation() {
  visiblePairs = 0;
  document.getElementById('pairSlider').value = 0;
  updatePairCount();
  
  animationTimer = setInterval(() => {
    if (visiblePairs >= 32) {
      clearInterval(animationTimer);
      animationTimer = null;
      return;
    }
    visiblePairs++;
    document.getElementById('pairSlider').value = visiblePairs;
    updatePairCount();
    render();
    showPairInfo(visiblePairs - 1);
  }, 600);
}

function updatePairCount() {
  visiblePairs = parseInt(document.getElementById('pairSlider').value);
  document.getElementById('pairCount').textContent = `${visiblePairs} / 32`;
  render();
}

function toggleLayer(layer) {
  layers[layer] = !layers[layer];
  const btnId = layer === 'canon1' ? 'btnCanon1' : layer === 'canon2' ? 'btnCanon2' : 'btnCentral';
  document.getElementById(btnId).classList.toggle('active');
  render();
}

// Build small matrix grid in sidebar
function buildSideMatrix() {
  const grid = document.getElementById('matrixGrid');
  grid.innerHTML = '';
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const upper = 7 - row;
      const lower = 7 - col;
      const wenEntry = wenSequence.find(h => h[1] === upper && h[2] === lower);
      const wenNum = wenEntry ? wenEntry[0] : '?';
      const isCentral = [1, 2, 63, 64].includes(wenNum);
      const isDot = [3, 4].includes(wenNum);
      const isCanon1 = wenNum <= 30;

      let bg = isCanon1 ? 'rgba(200,164,78,0.15)' : 'rgba(74,122,155,0.15)';
      let color = isCanon1 ? '#c8a44e' : '#4a7a9b';
      if (isCentral) { bg = 'rgba(184,58,58,0.3)'; color = '#b83a3a'; }
      if (isDot) { bg = 'rgba(122,154,106,0.25)'; color = '#7a9a6a'; }

      const cell = document.createElement('div');
      cell.className = 'pair-cell';
      cell.style.background = bg;
      cell.style.color = color;
      cell.textContent = wenNum;
      
      const pairIdx = pairs.findIndex(p => p.a[0] === wenNum || p.b[0] === wenNum);
      cell.addEventListener('click', () => { if (pairIdx >= 0) showPairInfo(pairIdx); });
      grid.appendChild(cell);
    }
  }
}

// Init
buildSideMatrix();
render();
showPairInfo(0);
</script>
</body>
</html>
